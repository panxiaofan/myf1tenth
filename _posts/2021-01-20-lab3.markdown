---
layout: post
title:  "Wall Following"
date:   2021-01-20 00:15:18 -0500
categories: F1Tenth LAB 3
---

## Introduction

This lab is about the implementation of wall following algorithm to make the car drive autonomously following the left wall of the Levine Hall map. The idea is that by using two laser beams with given angles, we can calculate its distance from the wall, then obtain the Cross Track Error. By using PID controller, where the input is Cross Track Error and the output is the correction of steering angle.
<img src="/assets/wall_following_noAC.png">

However, since our f1tenth racing car is in high speed, we need to take the forward distance into consideration. In the image below, the forward distance is denoted as AC. It is a user-defined value. The smaller AC is, the shorter distance you want the car to traverse to reach the desired track(where Cross Track Error is 0).
<img src="/assets/wall_following_AC.png">

The sign relation between steering angle and the Cross Track Error is shown below. Note this is very important. 
<img src="/assets/wall_following_sign.png">

The general formula of PID control is as below.
<img src="/assets/wall_following_pid.png">

In my case, I found the PD controller is sufficient for this task. The PD steering controller is shown as follow.
<img src="/assets/wall_following_pid.png">

When tunning the parameters for a better performance of PID controller, it is a good practice to refer to Ziegler-Nichols Method. 
<img src="/assets/wall_following_pid_tunning.png">


## Wall Following Algorithm
* step 1:
  Find the nearest LIDAR point and put a "safety bubble" around it of radius rb(radius of robot)
* step 2:
  Set the LaserScan range value of all points inside bubble to distance 0. All nonzero points are considered "free space"
* step 3:
  Find maximum sequence of consecutive non-zeros among the free-space points. This is the maximum gap where the car can drive towards.
* step 4:
  Find the best point among this maximum gap(naive way is choose the furthest point in free space and set steering angle towards it)

## Lab Implementation Explanation 

My implementation of the follow the gap node consists of these steps(each step corresponds to that in the above algorithm):

* step 1:
  Process LaserScan and set field of view of 100 degrees(50 to the left and 50 to the right), beyond this range, set the LaserScan range value to 0(m).
  Using a sliding 1D convolution window [0.2, 0.2, 0.2, 0.2, 0.2] to make a moving average of LaserScan range.
  Clipping all value between [0, 3]
  Find the minimum range value(closest_dist) and its angle(closest_angle) after doing above steps.  
* step 2:
  Make for loop, calculate the distance from the end of each LaserScan to the closest point by calculating the length of the arc (closest_dist * abs(angle_i - closest_angle)). If its length of arc is less than radius of robot, set its range value to 0.
* step 3:
  Find the max gap, the maximum sequence of consecutive non-zeros of the range array. 
* step 4:
  Find the angle with the largest range value within the max gap. Set steering angle to be exactly this angle.(If there are several angles with largest range value, set steering angle with the minimum absolute value).
  Velocity depends on the range value of the furthest point. you can refer to the video below.

<iframe width="700" height="400" src="https://www.youtube.com/embed/ctTJHueaTcY" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture" allowfullscreen></iframe>

## My Lab 4 Demo

<iframe width="800" height="400" src="https://www.youtube.com/embed/4HOsg2SRabw" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture" allowfullscreen></iframe>

## Related Learning Resources
[UV F1/10 course Slides](https://linklab-uva.github.io/autonomousracing/assets/files/Wall_Following.pdf)

UV F1/10 course Video: 
<iframe width="800" height="400" src="https://www.youtube.com/embed/AywLjJTPRGQ" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture" allowfullscreen></iframe>

Upenn F1/10 course Video: 
<iframe width="800" height="400" src="https://www.youtube.com/embed/7VLYP-z9hTw" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture" allowfullscreen></iframe>



I was experimenting for a long time with different values of K<sub>p</sub>,K<sub>d</sub> and K<sub>i</sub>. Using this I was able to find get a more insight what each of these constant is doing. I'm not 100% sure about, but I think that lowering K<sub>p</sub> makes the car less responsive to the error magnitude, as increasing this constant makes car move move with a twisting motion, K<sub>d</sub> seems to react faster to the growing error but it wasn't completely clear to me from simulation. K<sub>i</sub> didn't seem to do much even at higher values, but according to the research it should make the car more sensitive to error.


I've found that setting the right theta had probably biggest impact on the car ability to follow the wall without bouncing to the corners. Also one additional thing while filtering nan and inf values from the scan reading, I also removed the readings that are higher angle that the lidar sensor on real car is able to read, which is apparently 270 degrees. The car in the simulation has no problem reading in 360 dergees so there are none infinite or nan values in simulation.


<iframe width="800" height="400" src="https://www.youtube.com/embed/fJCXhTbDnV4" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture" allowfullscreen></iframe>

